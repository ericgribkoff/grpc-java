/*
 * Copyright 2018 The gRPC Authors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package io.grpc.internal;

import com.google.common.annotations.VisibleForTesting;
import io.grpc.ManagedChannel;
import java.lang.ref.Reference;
import java.lang.ref.ReferenceQueue;
import java.lang.ref.SoftReference;
import java.lang.ref.WeakReference;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;
import java.util.logging.Level;
import java.util.logging.LogRecord;
import java.util.logging.Logger;

final class ManagedChannelOrphanWrapper extends ForwardingManagedChannel {
  // This holds the ref objects after the referent has been deallocated
  private static final ReferenceQueue<ManagedChannelOrphanWrapper> refqueue =
      new ReferenceQueue<ManagedChannelOrphanWrapper>();
  // Retain the References so they don't get GC'd
  private static final ConcurrentMap<ManagedChannelReference, ManagedChannelReference> refs =
      new ConcurrentHashMap<ManagedChannelReference, ManagedChannelReference>();
  private static final Logger logger =
      Logger.getLogger(ManagedChannelOrphanWrapper.class.getName());

  private final ManagedChannelReference phantom;

  ManagedChannelOrphanWrapper(ManagedChannel delegate) {
    this(delegate, refqueue, refs);
  }

  @VisibleForTesting
  ManagedChannelOrphanWrapper(
      ManagedChannel delegate,
      ReferenceQueue<ManagedChannelOrphanWrapper> refqueue,
      ConcurrentMap<ManagedChannelReference, ManagedChannelReference> refs) {
    super(delegate);
    phantom = new ManagedChannelReference(this, delegate, refqueue, refs);
  }

  @Override
  public ManagedChannel shutdown() {
    phantom.shutdown = true;
    phantom.clear(); // invoking here lets gc release app after shutdown, even with hard ref to channel in MCR
    return super.shutdown();
  }

  @Override
  public ManagedChannel shutdownNow() {
    phantom.shutdownNow = true;
//    phantom.clear();
    return super.shutdownNow();
  }

  @Override
  public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {
    boolean ret = super.awaitTermination(timeout, unit);
    if (ret) {
      phantom.clear();
    }
    return ret;
  }

  // ManagedChannelReference itself is a weak ref to a ManagedChannelOrphanWrapper
  @VisibleForTesting
  static final class ManagedChannelReference extends WeakReference<ManagedChannelOrphanWrapper> {

    private static final String ALLOCATION_SITE_PROPERTY_NAME =
        "io.grpc.ManagedChannel.enableAllocationTracking";

    private static final boolean ENABLE_ALLOCATION_TRACKING =
        Boolean.parseBoolean(System.getProperty(ALLOCATION_SITE_PROPERTY_NAME, "true"));
    private static final RuntimeException missingCallSite = missingCallSite();

    private final ReferenceQueue<ManagedChannelOrphanWrapper> refqueue;
    private final ConcurrentMap<ManagedChannelReference, ManagedChannelReference> refs;

    private final ManagedChannel channel;
    private final String channelStr;
    private final Reference<RuntimeException> allocationSite;
    private volatile boolean shutdown;
    private volatile boolean shutdownNow;

    // ManagedChannelReference stores a ref to the underlying channel in refs.
    // It is the responsibility of cleanQueue to deference this actual channel
    // when the ManagedChannelOrphanWrapper is deallocated and put onto the queue.
    // This should *always* happen when a new channel is created, as this will
    // call the constructor here.
    // I believe that the code here *is* correct (albeit dangerous) as long
    // as clean queue is being invoked: I believe that the Scribe app is leaking
    // the "channel" (really a ManagedChannelOrphanWrapper) and therefore the
    // ManagedChannelReference never gets added to the queue here, and therefore
    // is not properly cleaned up. This should actually be "ok", as the channel is
    // shutdown...but we retain the hard reference to the channel impl and therefore
    // the app's context.
    ManagedChannelReference(
        ManagedChannelOrphanWrapper orphanable,
        ManagedChannel channel,
        ReferenceQueue<ManagedChannelOrphanWrapper> refqueue,
        ConcurrentMap<ManagedChannelReference, ManagedChannelReference> refs) {
      super(orphanable, refqueue);
      allocationSite = new SoftReference<RuntimeException>(missingCallSite); /*
          ENABLE_ALLOCATION_TRACKING
              ? new RuntimeException("ManagedChannel allocation site")
              : missingCallSite);*/
      this.channel = null; // setting to null lets "app" be gc'ed even if not shutdown
      this.channelStr = channel.toString();
      this.refqueue = refqueue;
      this.refs = refs;
      this.refs.put(this, this);
      System.out.println("adding this: " + this + " with ref to " + this.channel);
      cleanQueue(refqueue);
    }

    /**
     * This clear() is *not* called automatically by the JVM.  As this is a weak ref, the reference
     * will be cleared automatically by the JVM, but will not be removed from {@link #refs}.
     * We do it here to avoid this ending up on the reference queue.
     */
    @Override
    public void clear() {
      clearInternal();
      // We run this here to periodically clean up the queue if at least some of the channels are
      // being shutdown properly.
      cleanQueue(refqueue);
    }

    // avoid reentrancy
    private void clearInternal() {
      super.clear();
      System.out.println("removing this: " + this);
      refs.remove(this);
      allocationSite.clear();
    }

    private static RuntimeException missingCallSite() {
      RuntimeException e = new RuntimeException(
          "ManagedChannel allocation site not recorded.  Set -D"
              + ALLOCATION_SITE_PROPERTY_NAME + "=true to enable it");
      e.setStackTrace(new StackTraceElement[0]);
      return e;
    }

    @VisibleForTesting
    static int cleanQueue(ReferenceQueue<ManagedChannelOrphanWrapper> refqueue) {
      System.out.println("cleaning queue");
      ManagedChannelReference ref;
      int orphanedChannels = 0;
      // We get back the weakref to a deallocated ManagedChannelOrphanWrapper, which
      // is a ManagedChannelReference
      while ((ref = (ManagedChannelReference) refqueue.poll()) != null) {
        System.out.println("ref" + ref);
        RuntimeException maybeAllocationSite = ref.allocationSite.get();
        ref.clearInternal(); // technically the reference is gone already.
        if (!ref.shutdown) { // && ref.channel.isTerminated())) {
          orphanedChannels++;
          Level level = ref.shutdownNow ? Level.FINE : Level.SEVERE;
          if (logger.isLoggable(level)) {
            String fmt =
                "*~*~*~ Channel {0} was not "
                // Prefer to complain about shutdown if neither has been called.
                + (!ref.shutdown ? "shutdown" : "terminated")
                + " properly!!! ~*~*~*"
                + System.getProperty("line.separator")
                + "    Make sure to call shutdown()/shutdownNow() and wait "
                + "until awaitTermination() returns true.";
            LogRecord lr = new LogRecord(level, fmt);
            lr.setLoggerName(logger.getName());
            lr.setParameters(new Object[]{ref.channelStr});
            lr.setThrown(maybeAllocationSite);
            logger.log(lr);
          }
        }
      }
      return orphanedChannels;
    }
  }
}
